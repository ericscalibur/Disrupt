"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.requestInvoice = exports.requestInvoiceWithServiceParams = void 0;
var tslib_1 = require("tslib");
var utils_1 = require("./utils");
var request_pay_service_params_1 = require("./request-pay-service-params");
var requestInvoiceWithServiceParams = function (_a) { return tslib_1.__awaiter(void 0, [_a], void 0, function (_b) {
    var callback, commentAllowed, min, max, invoiceParams, data, invoice, decodedInvoice, descriptionHash, hasValidDescriptionHash, hasValidAmount, successAction, decipher;
    var params = _b.params, tokens = _b.tokens, comment = _b.comment, _c = _b.onionAllowed, onionAllowed = _c === void 0 ? false : _c, _d = _b.validateInvoice, validateInvoice = _d === void 0 ? false : _d, _e = _b.fetchGet, fetchGet = _e === void 0 ? utils_1.getJson : _e;
    return tslib_1.__generator(this, function (_f) {
        switch (_f.label) {
            case 0:
                callback = params.callback, commentAllowed = params.commentAllowed, min = params.min, max = params.max;
                if (!(0, utils_1.isValidAmount)({ amount: tokens, min: min, max: max }))
                    throw new Error('Invalid amount');
                if (!(0, utils_1.isUrl)(callback))
                    throw new Error('Callback must be a valid url');
                if (!onionAllowed && (0, utils_1.isOnionUrl)(callback))
                    throw new Error('Onion requests not allowed');
                invoiceParams = {
                    amount: tokens * 1000,
                };
                if (comment && commentAllowed > 0 && comment.length > commentAllowed)
                    throw new Error("The comment length must be ".concat(commentAllowed, " characters or fewer"));
                if (comment)
                    invoiceParams.comment = comment;
                return [4 /*yield*/, fetchGet({ url: callback, params: invoiceParams })];
            case 1:
                data = _f.sent();
                invoice = data && data.pr && data.pr.toString();
                if (!invoice)
                    throw new Error('Invalid pay service invoice');
                decodedInvoice = (0, utils_1.decodeInvoice)(invoice);
                descriptionHash = decodedInvoice === null || decodedInvoice === void 0 ? void 0 : decodedInvoice.tags.find(function (t) { return t.tagName === 'purpose_commit_hash'; });
                hasValidDescriptionHash = descriptionHash
                    ? params.metadataHash === descriptionHash.data
                    : false;
                if (validateInvoice && !hasValidDescriptionHash)
                    throw new Error("Invoice description hash doesn't match metadata hash.");
                hasValidAmount = decodedInvoice
                    ? decodedInvoice.satoshis === tokens
                    : false;
                if (validateInvoice && !hasValidAmount)
                    throw new Error("Invalid invoice amount ".concat(decodedInvoice === null || decodedInvoice === void 0 ? void 0 : decodedInvoice.satoshis, ". Expected ").concat(tokens));
                successAction = undefined;
                if (data.successAction) {
                    decipher = function (preimage) {
                        return (0, utils_1.decipherAES)({ preimage: preimage, successAction: data.successAction });
                    };
                    successAction = Object.assign({ decipher: decipher }, data.successAction);
                }
                return [2 /*return*/, {
                        params: params,
                        rawData: data,
                        invoice: invoice,
                        successAction: successAction,
                        hasValidAmount: hasValidAmount,
                        hasValidDescriptionHash: hasValidDescriptionHash,
                        validatePreimage: function (preimage) {
                            return (0, utils_1.isValidPreimage)({ invoice: invoice, preimage: preimage });
                        },
                    }];
        }
    });
}); };
exports.requestInvoiceWithServiceParams = requestInvoiceWithServiceParams;
var requestInvoice = function (_a) { return tslib_1.__awaiter(void 0, [_a], void 0, function (_b) {
    var params;
    var lnUrlOrAddress = _b.lnUrlOrAddress, tokens = _b.tokens, comment = _b.comment, _c = _b.onionAllowed, onionAllowed = _c === void 0 ? false : _c, _d = _b.validateInvoice, validateInvoice = _d === void 0 ? false : _d, _e = _b.fetchGet, fetchGet = _e === void 0 ? utils_1.getJson : _e;
    return tslib_1.__generator(this, function (_f) {
        switch (_f.label) {
            case 0: return [4 /*yield*/, (0, request_pay_service_params_1.requestPayServiceParams)({
                    lnUrlOrAddress: lnUrlOrAddress,
                    onionAllowed: onionAllowed,
                    fetchGet: fetchGet,
                })];
            case 1:
                params = _f.sent();
                return [2 /*return*/, (0, exports.requestInvoiceWithServiceParams)({
                        params: params,
                        tokens: tokens,
                        comment: comment,
                        onionAllowed: onionAllowed,
                        validateInvoice: validateInvoice,
                        fetchGet: fetchGet,
                    })];
        }
    });
}); };
exports.requestInvoice = requestInvoice;
